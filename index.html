<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>PureConfig Presentation</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
<section data-markdown><script type="text/template">
# [PureConfig](https://github.com/pureconfig/pureconfig)

Configuration made simple
</script></section>
<section data-markdown><script type="text/template">
### The problem

Configuration libraries like TypeSafe config focus on: <!-- .element: style="text-align: left;"  -->
  1. loading configuration from different sources sources (files, environment variables...)
  2. providing an API to access the configuration

</script></section>
<section data-markdown><script type="text/template">
### The problem

From the user point of view:<!-- .element: style="text-align: left;"  -->

1. loading configuration is easy
  - it's just a method to call
  - the complex part is hidden internally to the library
2. accessing the configuration is much more complex

</script></section>
<section data-markdown><script type="text/template">
### The problem

--<!-- .element: style="visibility:hidden;" -->

Let's see it with an example. We want to load the configuration<!-- .element: style="font-size:85%;text-align: left;"  -->

-- <!-- .element: style="font-size:10%;visibility:hidden;" -->

```scala
case class ServerConfig(address: String, port: Int)
case class MyConfig(server: ServerConfig, numThreads: Int)
```

from the configuration file<!-- .element: style="font-size:85%;text-align: left;"  -->

```javascript
my.app {
  server {
    address: "111.222.333.444"
    port: 1234
  }
  numThreads: 1
}
```

--<!-- .element: style="visibility:hidden;" -->

</script></section>
<section data-markdown><script type="text/template">
### The problem

Loading the configuration:<!-- .element: style="font-size:70%;text-align: left;"  -->

```scala
val rawConfig = ConfigFactory.load()
```
<!-- .element: style="width:100%;height:100%;" -->

Accessing the configuration:<!-- .element: style="font-size:70%;text-align: left;"  -->

```scala
val serverAddress = rawConfig.getString("my.app.server.address")
if (isServerAddressNotValid(serverAddress))
  throw new Exception(s"$serverAddress is not a valid address")
val serverPort = rawConfig.getInt("my.app.server.port")
if (isServerPortNotValid(serverPort))
  throw new Exception(s"$serverPort is not a valid port")
val numThreads = rawConfig.getInt("my.app.numThreads")
if (numThreads < 1)
  throw new Exception(s"$numThreads must be a positive number")
val serverConfig = ServerConfig(serverAddress, serverPort)
val config = MyConfig(serverConfig, numThreads)
```
<!-- .element: style="width:100%;height:100%;" -->
</script></section>
<section data-markdown><script type="text/template">
### The problem

- a lot of code for a relatively small task
- boilerplate code everywhere: 
  - the field type already tells me what kind of conversion is needed<!-- .element: style="font-size:80%;"  -->
    - e.g. Int needs a conversion to Int (duh)<!-- .element: style="font-size:70%;"  -->
  - the field path already tells me where to find the  configuration<!-- .element: style="font-size:80%;"  -->
    - e.g. server.port can be found at my.app.server.port<!-- .element: style="font-size:70%;"  -->
- error prone, e.g. the path is a string and it must be consistent with the class path
- difficult to maintain
</script></section>
<section data-markdown><script type="text/template">
### The problem

Given the user configuration class, can we derive the configuration readers automatically?
</script></section>
<section data-markdown><script type="text/template">
### PureConfig

PureConfig is a Scala library that uses Shapeless to automatically derive configuration readers and writers for a given class<!-- .element: style="text-align:left;" -->

-- <!-- .element: style="font-size:40%;visibility:hidden;" -->

```scala
val config = pureconfig.loadConfig[MyConfig]("my.app")
```

</script></section>
<section data-markdown><script type="text/template">
### PureConfig

It is designed with two ideas in mind:<!-- .element: style="text-align:left;" -->
- Minimal effort needed to load your configuration
- Easy to extend and add support for custom readers/writers
</script></section>
<section data-markdown><script type="text/template">
### Supported types

- case classes
- ADTs
- all primitive types (String, Boolean, ...)
- all collections implementing TraversableOnce (List, ...)
- Map with String keys
- Option for optional values
- java.time.*, URL, URI, UUID, Path, (Finite)Duration ...
</script></section>
<section data-markdown><script type="text/template">
### Supported types example

```scala
case class ServerConfig(address: String, port: Int)
sealed trait TraceMode
case object DontTrace extends TraceMode
case class TraceTo(server: ServerConfig) extends TraceMode
case class Config(servers: List[ServerConfig], trace: TraceMode)
```
<!-- .element: style="width:100%;height:100%;" -->

```javascript
my.app {
  servers: [{ address: "111.222.333.444", port: 1234 }]
  trace: {
    type: traceto
    server: { address: "444.333.222.111", port: 4321 }
  }
}
```
<!-- .element: style="width:100%;height:100%;" -->

```scala
val config = pureconfig.loadConfig[Config](rawConfig)
println(config)
// Right(
//   MyConfig(
//     List(ServerConfig("111.222.333.444", 1234)),
//     TraceTo(ServerConfig("444.333.222.111", 4321))))
```
<!-- .element: style="width:100%;height:100%;" -->
</script></section>
<section data-markdown><script type="text/template">
### Extensibility

- Everything that has a `ConfigReader` / `ConfigWriter` instance can be read/written from/to a configuration value
- Support for types not provided by PureConfig can be added by providing the required instances

```scala
implicit val utConfigReader = ConfigReader[UT].fromString(/*... */)
```
<!-- .element: style="width:100%;height:100%;" -->
</script></section>
<section data-markdown><script type="text/template">
### Extensibility example: Squants

- [Squants](http://www.squants.com/) is a framework of data types for representing Quantities<!-- .reveal li: style="font-size:70%;" -->
- the pureconfig-squants module adds support for those types

```scala
case class HowConfig(far: Length, hot: temporature)
val conf = parseString("""{
  far: 42.195 km
  hot: 56.7° C
}""")
loadConfig[HowConfiguration](conf)
// Right(HowConfiguration(42.195 km,56.7°C))
```
<!-- .element: style="width:100%;height:100%;" -->
</script></section>
<section data-markdown><script type="text/template">
### Extensibility example: Squants

- pureconfig-squants is just a collection of `ConfigReader`s and `ConfigWriter`s for the datatypes, e.g.

```scala
implicit val temperatureConfigConvert =
  viaNonEmptyStringTry[Temperature](Temperature.apply, _.toString)
```
<!-- .element: style="width:100%;height:100%;" -->

- the library adds supports for tens of new datatypes in less than 200 lines of code...
</script></section>
<section data-markdown><script type="text/template">
### Extensibility and minimal effort

Focus on the support for specific types that you want to add or modify and let PureConfig do the rest of the work.
</script></section>
<!--				<section>Slide 1</section>
				<section>Slide 2</section>
-->
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
